/*
 * Subscriptions
 * You can use billing plans and subscriptions to create subscriptions that process recurring PayPal payments for physical or digital goods, or services. A plan includes pricing and billing cycle information that defines the amount and frequency of charge for a subscription. You can also define a fixed plan, such as a $5 basic plan or a volume- or graduated-based plan with pricing tiers based on the quantity purchased. For more information, see <a href=\"/docs/subscriptions/\">Subscriptions Overview</a>.
 *
 * The version of the OpenAPI document: 1.6
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import org.openapitools.client.model.AddressPortable;
import org.openapitools.client.model.Name;
import org.openapitools.client.model.PaymentSource;
import org.openapitools.client.model.PhoneWithType;
import org.openapitools.client.model.ShippingDetail;
import org.openapitools.client.model.TaxInfo;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.StringJoiner;

/**
 * The subscriber request information .
 */
@JsonPropertyOrder({
  SubscriberRequest.JSON_PROPERTY_EMAIL_ADDRESS,
  SubscriberRequest.JSON_PROPERTY_PAYER_ID,
  SubscriberRequest.JSON_PROPERTY_NAME,
  SubscriberRequest.JSON_PROPERTY_PHONE,
  SubscriberRequest.JSON_PROPERTY_BIRTH_DATE,
  SubscriberRequest.JSON_PROPERTY_TAX_INFO,
  SubscriberRequest.JSON_PROPERTY_ADDRESS,
  SubscriberRequest.JSON_PROPERTY_SHIPPING_ADDRESS,
  SubscriberRequest.JSON_PROPERTY_PAYMENT_SOURCE
})
@JsonTypeName("subscriber_request")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-05-08T11:30:41.643502082Z[Atlantic/Reykjavik]")
public class SubscriberRequest {
  public static final String JSON_PROPERTY_EMAIL_ADDRESS = "email_address";
  private String emailAddress;

  public static final String JSON_PROPERTY_PAYER_ID = "payer_id";
  private String payerId;

  public static final String JSON_PROPERTY_NAME = "name";
  private Name name;

  public static final String JSON_PROPERTY_PHONE = "phone";
  private PhoneWithType phone;

  public static final String JSON_PROPERTY_BIRTH_DATE = "birth_date";
  private String birthDate;

  public static final String JSON_PROPERTY_TAX_INFO = "tax_info";
  private TaxInfo taxInfo;

  public static final String JSON_PROPERTY_ADDRESS = "address";
  private AddressPortable address;

  public static final String JSON_PROPERTY_SHIPPING_ADDRESS = "shipping_address";
  private ShippingDetail shippingAddress;

  public static final String JSON_PROPERTY_PAYMENT_SOURCE = "payment_source";
  private PaymentSource paymentSource;

  public SubscriberRequest() {
  }

  public SubscriberRequest emailAddress(String emailAddress) {
    
    this.emailAddress = emailAddress;
    return this;
  }

   /**
   * The internationalized email address.&lt;blockquote&gt;&lt;strong&gt;Note:&lt;/strong&gt; Up to 64 characters are allowed before and 255 characters are allowed after the &lt;code&gt;@&lt;/code&gt; sign. However, the generally accepted maximum length for an email address is 254 characters. The pattern verifies that an unquoted &lt;code&gt;@&lt;/code&gt; sign exists.&lt;/blockquote&gt;
   * @return emailAddress
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_EMAIL_ADDRESS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getEmailAddress() {
    return emailAddress;
  }


  @JsonProperty(JSON_PROPERTY_EMAIL_ADDRESS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setEmailAddress(String emailAddress) {
    this.emailAddress = emailAddress;
  }


  public SubscriberRequest payerId(String payerId) {
    
    this.payerId = payerId;
    return this;
  }

   /**
   * The account identifier for a PayPal account.
   * @return payerId
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PAYER_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getPayerId() {
    return payerId;
  }


  @JsonProperty(JSON_PROPERTY_PAYER_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPayerId(String payerId) {
    this.payerId = payerId;
  }


  public SubscriberRequest name(Name name) {
    
    this.name = name;
    return this;
  }

   /**
   * Get name
   * @return name
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Name getName() {
    return name;
  }


  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setName(Name name) {
    this.name = name;
  }


  public SubscriberRequest phone(PhoneWithType phone) {
    
    this.phone = phone;
    return this;
  }

   /**
   * Get phone
   * @return phone
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PHONE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public PhoneWithType getPhone() {
    return phone;
  }


  @JsonProperty(JSON_PROPERTY_PHONE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPhone(PhoneWithType phone) {
    this.phone = phone;
  }


  public SubscriberRequest birthDate(String birthDate) {
    
    this.birthDate = birthDate;
    return this;
  }

   /**
   * The stand-alone date, in [Internet date and time format](https://tools.ietf.org/html/rfc3339#section-5.6). To represent special legal values, such as a date of birth, you should use dates with no associated time or time-zone data. Whenever possible, use the standard &#x60;date_time&#x60; type. This regular expression does not validate all dates. For example, February 31 is valid and nothing is known about leap years.
   * @return birthDate
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_BIRTH_DATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getBirthDate() {
    return birthDate;
  }


  @JsonProperty(JSON_PROPERTY_BIRTH_DATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setBirthDate(String birthDate) {
    this.birthDate = birthDate;
  }


  public SubscriberRequest taxInfo(TaxInfo taxInfo) {
    
    this.taxInfo = taxInfo;
    return this;
  }

   /**
   * Get taxInfo
   * @return taxInfo
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_TAX_INFO)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public TaxInfo getTaxInfo() {
    return taxInfo;
  }


  @JsonProperty(JSON_PROPERTY_TAX_INFO)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTaxInfo(TaxInfo taxInfo) {
    this.taxInfo = taxInfo;
  }


  public SubscriberRequest address(AddressPortable address) {
    
    this.address = address;
    return this;
  }

   /**
   * Get address
   * @return address
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_ADDRESS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public AddressPortable getAddress() {
    return address;
  }


  @JsonProperty(JSON_PROPERTY_ADDRESS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAddress(AddressPortable address) {
    this.address = address;
  }


  public SubscriberRequest shippingAddress(ShippingDetail shippingAddress) {
    
    this.shippingAddress = shippingAddress;
    return this;
  }

   /**
   * Get shippingAddress
   * @return shippingAddress
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_SHIPPING_ADDRESS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public ShippingDetail getShippingAddress() {
    return shippingAddress;
  }


  @JsonProperty(JSON_PROPERTY_SHIPPING_ADDRESS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setShippingAddress(ShippingDetail shippingAddress) {
    this.shippingAddress = shippingAddress;
  }


  public SubscriberRequest paymentSource(PaymentSource paymentSource) {
    
    this.paymentSource = paymentSource;
    return this;
  }

   /**
   * Get paymentSource
   * @return paymentSource
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PAYMENT_SOURCE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public PaymentSource getPaymentSource() {
    return paymentSource;
  }


  @JsonProperty(JSON_PROPERTY_PAYMENT_SOURCE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPaymentSource(PaymentSource paymentSource) {
    this.paymentSource = paymentSource;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SubscriberRequest subscriberRequest = (SubscriberRequest) o;
    return Objects.equals(this.emailAddress, subscriberRequest.emailAddress) &&
        Objects.equals(this.payerId, subscriberRequest.payerId) &&
        Objects.equals(this.name, subscriberRequest.name) &&
        Objects.equals(this.phone, subscriberRequest.phone) &&
        Objects.equals(this.birthDate, subscriberRequest.birthDate) &&
        Objects.equals(this.taxInfo, subscriberRequest.taxInfo) &&
        Objects.equals(this.address, subscriberRequest.address) &&
        Objects.equals(this.shippingAddress, subscriberRequest.shippingAddress) &&
        Objects.equals(this.paymentSource, subscriberRequest.paymentSource);
  }

  @Override
  public int hashCode() {
    return Objects.hash(emailAddress, payerId, name, phone, birthDate, taxInfo, address, shippingAddress, paymentSource);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SubscriberRequest {\n");
    sb.append("    emailAddress: ").append(toIndentedString(emailAddress)).append("\n");
    sb.append("    payerId: ").append(toIndentedString(payerId)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    phone: ").append(toIndentedString(phone)).append("\n");
    sb.append("    birthDate: ").append(toIndentedString(birthDate)).append("\n");
    sb.append("    taxInfo: ").append(toIndentedString(taxInfo)).append("\n");
    sb.append("    address: ").append(toIndentedString(address)).append("\n");
    sb.append("    shippingAddress: ").append(toIndentedString(shippingAddress)).append("\n");
    sb.append("    paymentSource: ").append(toIndentedString(paymentSource)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `email_address` to the URL query string
    if (getEmailAddress() != null) {
      try {
        joiner.add(String.format("%semail_address%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getEmailAddress()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `payer_id` to the URL query string
    if (getPayerId() != null) {
      try {
        joiner.add(String.format("%spayer_id%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getPayerId()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `name` to the URL query string
    if (getName() != null) {
      joiner.add(getName().toUrlQueryString(prefix + "name" + suffix));
    }

    // add `phone` to the URL query string
    if (getPhone() != null) {
      joiner.add(getPhone().toUrlQueryString(prefix + "phone" + suffix));
    }

    // add `birth_date` to the URL query string
    if (getBirthDate() != null) {
      try {
        joiner.add(String.format("%sbirth_date%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getBirthDate()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `tax_info` to the URL query string
    if (getTaxInfo() != null) {
      joiner.add(getTaxInfo().toUrlQueryString(prefix + "tax_info" + suffix));
    }

    // add `address` to the URL query string
    if (getAddress() != null) {
      joiner.add(getAddress().toUrlQueryString(prefix + "address" + suffix));
    }

    // add `shipping_address` to the URL query string
    if (getShippingAddress() != null) {
      joiner.add(getShippingAddress().toUrlQueryString(prefix + "shipping_address" + suffix));
    }

    // add `payment_source` to the URL query string
    if (getPaymentSource() != null) {
      joiner.add(getPaymentSource().toUrlQueryString(prefix + "payment_source" + suffix));
    }

    return joiner.toString();
  }

}

