/*
 * Subscriptions
 * You can use billing plans and subscriptions to create subscriptions that process recurring PayPal payments for physical or digital goods, or services. A plan includes pricing and billing cycle information that defines the amount and frequency of charge for a subscription. You can also define a fixed plan, such as a $5 basic plan or a volume- or graduated-based plan with pricing tiers based on the quantity purchased. For more information, see <a href=\"/docs/subscriptions/\">Subscriptions Overview</a>.
 *
 * The version of the OpenAPI document: 1.6
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import org.openapitools.client.model.PayeePaymentMethodPreference;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.StringJoiner;

/**
 * The customer and merchant payment preferences.
 */
@JsonPropertyOrder({
  PaymentMethod.JSON_PROPERTY_PAYER_SELECTED,
  PaymentMethod.JSON_PROPERTY_PAYEE_PREFERRED,
  PaymentMethod.JSON_PROPERTY_STANDARD_ENTRY_CLASS_CODE
})
@JsonTypeName("payment_method")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2024-05-08T11:30:41.643502082Z[Atlantic/Reykjavik]")
public class PaymentMethod {
  public static final String JSON_PROPERTY_PAYER_SELECTED = "payer_selected";
  private String payerSelected = "PAYPAL";

  public static final String JSON_PROPERTY_PAYEE_PREFERRED = "payee_preferred";
  private PayeePaymentMethodPreference payeePreferred = PayeePaymentMethodPreference.UNRESTRICTED;

  /**
   * NACHA (the regulatory body governing the ACH network) requires that API callers (merchants, partners) obtain the consumer’s explicit authorization before initiating a transaction. To stay compliant, you’ll need to make sure that you retain a compliant authorization for each transaction that you originate to the ACH Network using this API. ACH transactions are categorized (using SEC codes) by how you capture authorization from the Receiver (the person whose bank account is being debited or credited). PayPal supports the following SEC codes.
   */
  public enum StandardEntryClassCodeEnum {
    TEL("TEL"),
    
    WEB("WEB"),
    
    CCD("CCD"),
    
    PPD("PPD");

    private String value;

    StandardEntryClassCodeEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static StandardEntryClassCodeEnum fromValue(String value) {
      for (StandardEntryClassCodeEnum b : StandardEntryClassCodeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_STANDARD_ENTRY_CLASS_CODE = "standard_entry_class_code";
  private StandardEntryClassCodeEnum standardEntryClassCode = StandardEntryClassCodeEnum.WEB;

  public PaymentMethod() {
  }

  public PaymentMethod payerSelected(String payerSelected) {
    
    this.payerSelected = payerSelected;
    return this;
  }

   /**
   * The customer-selected payment method on the merchant site.
   * @return payerSelected
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PAYER_SELECTED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getPayerSelected() {
    return payerSelected;
  }


  @JsonProperty(JSON_PROPERTY_PAYER_SELECTED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPayerSelected(String payerSelected) {
    this.payerSelected = payerSelected;
  }


  public PaymentMethod payeePreferred(PayeePaymentMethodPreference payeePreferred) {
    
    this.payeePreferred = payeePreferred;
    return this;
  }

   /**
   * Get payeePreferred
   * @return payeePreferred
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PAYEE_PREFERRED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public PayeePaymentMethodPreference getPayeePreferred() {
    return payeePreferred;
  }


  @JsonProperty(JSON_PROPERTY_PAYEE_PREFERRED)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPayeePreferred(PayeePaymentMethodPreference payeePreferred) {
    this.payeePreferred = payeePreferred;
  }


  public PaymentMethod standardEntryClassCode(StandardEntryClassCodeEnum standardEntryClassCode) {
    
    this.standardEntryClassCode = standardEntryClassCode;
    return this;
  }

   /**
   * NACHA (the regulatory body governing the ACH network) requires that API callers (merchants, partners) obtain the consumer’s explicit authorization before initiating a transaction. To stay compliant, you’ll need to make sure that you retain a compliant authorization for each transaction that you originate to the ACH Network using this API. ACH transactions are categorized (using SEC codes) by how you capture authorization from the Receiver (the person whose bank account is being debited or credited). PayPal supports the following SEC codes.
   * @return standardEntryClassCode
  **/
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_STANDARD_ENTRY_CLASS_CODE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public StandardEntryClassCodeEnum getStandardEntryClassCode() {
    return standardEntryClassCode;
  }


  @JsonProperty(JSON_PROPERTY_STANDARD_ENTRY_CLASS_CODE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStandardEntryClassCode(StandardEntryClassCodeEnum standardEntryClassCode) {
    this.standardEntryClassCode = standardEntryClassCode;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PaymentMethod paymentMethod = (PaymentMethod) o;
    return Objects.equals(this.payerSelected, paymentMethod.payerSelected) &&
        Objects.equals(this.payeePreferred, paymentMethod.payeePreferred) &&
        Objects.equals(this.standardEntryClassCode, paymentMethod.standardEntryClassCode);
  }

  @Override
  public int hashCode() {
    return Objects.hash(payerSelected, payeePreferred, standardEntryClassCode);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PaymentMethod {\n");
    sb.append("    payerSelected: ").append(toIndentedString(payerSelected)).append("\n");
    sb.append("    payeePreferred: ").append(toIndentedString(payeePreferred)).append("\n");
    sb.append("    standardEntryClassCode: ").append(toIndentedString(standardEntryClassCode)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `payer_selected` to the URL query string
    if (getPayerSelected() != null) {
      try {
        joiner.add(String.format("%spayer_selected%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getPayerSelected()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `payee_preferred` to the URL query string
    if (getPayeePreferred() != null) {
      try {
        joiner.add(String.format("%spayee_preferred%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getPayeePreferred()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `standard_entry_class_code` to the URL query string
    if (getStandardEntryClassCode() != null) {
      try {
        joiner.add(String.format("%sstandard_entry_class_code%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getStandardEntryClassCode()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    return joiner.toString();
  }

}

